pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 14))
nx.draw(
G, pos, with_labels=True, node_size=2500, node_color="lightblue",
font_size=12, font_weight="bold", edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
# Costruzione del grafo delle permutazioni di 3 lettere
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: [], 3: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
# Livello 3 = stesso nome dei nodi finali (nessuna nuova aggiunta)
for (node2, _, _) in levels[2]:
levels[3].append((node2, 3, 0))
return G, levels
# Posizionamento centrato con ultimo livello largo come il penultimo
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
if depth == max_depth:
width = len(levels[depth - 1])
else:
width = len(nodes)
# stesso spacing verticale per ultimo e penultimo livello
effective_depth = depth if depth < max_depth else max_depth - 1
spacing = base_spacing + effective_depth * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 14))
nx.draw(
G, pos, with_labels=True, node_size=1500, node_color="lightblue",
font_size=12, font_weight="bold", edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
# Costruzione del grafo delle permutazioni di 3 lettere
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: [], 3: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
# Livello 3 = stesso nome dei nodi finali (nessuna nuova aggiunta)
for (node2, _, _) in levels[2]:
levels[3].append((node2, 3, 0))
return G, levels
# Posizionamento centrato con ultimo livello largo come il penultimo
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
if depth == max_depth:
width = len(levels[depth - 1])
else:
width = len(nodes)
# stesso spacing verticale per ultimo e penultimo livello
effective_depth = depth if depth < max_depth else max_depth - 1
spacing = base_spacing + effective_depth * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 14))
nx.draw(
G, pos, with_labels=True, node_size=150, node_color="lightblue",
font_size=12, font_weight="bold", edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
# Costruzione del grafo delle permutazioni di 3 lettere
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: [], 3: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
# Livello 3 = stesso nome dei nodi finali (nessuna nuova aggiunta)
for (node2, _, _) in levels[2]:
levels[3].append((node2, 3, 0))
return G, levels
# Posizionamento centrato con ultimo livello largo come il penultimo
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
if depth == max_depth:
width = len(levels[depth - 1])
else:
width = len(nodes)
# stesso spacing verticale per ultimo e penultimo livello
effective_depth = depth if depth < max_depth else max_depth - 1
spacing = base_spacing + effective_depth * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 14))
nx.draw(
G, pos, with_labels=True, node_size=1000, node_color="lightblue",
font_size=12, font_weight="bold", edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
G
generate_permutation_tree(letters)
pos
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2 (perm. complete)
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
return G, levels
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
width = len(levels[depth - 1]) if depth == max_depth else len(nodes)
spacing = base_spacing + (depth if depth < max_depth else max_depth - 1) * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['a', 'b', 'c']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 12))
nx.draw(
G, pos, with_labels=True, node_size=2500, node_color="lightblue",
font_size=12, font_weight="bold", edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2 (perm. complete)
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
return G, levels
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
width = len(levels[depth - 1]) if depth == max_depth else len(nodes)
spacing = base_spacing + (depth if depth < max_depth else max_depth - 1) * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 12))
nx.draw(
G, pos, with_labels=True, node_size=1000, node_color="lightblue",
font_size=10, edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
generate_permutation_tree(letters)
pos
G
generate_permutation_tree(letters)
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((l1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2 (perm. complete)
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((l2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
return G, levels
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
width = len(levels[depth - 1]) if depth == max_depth else len(nodes)
spacing = base_spacing + (depth if depth < max_depth else max_depth - 1) * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 12))
nx.draw(
G, pos, with_labels=True, node_size=1000, node_color="lightblue",
font_size=10, edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2 (perm. complete)
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
return G, levels
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
width = len(levels[depth - 1]) if depth == max_depth else len(nodes)
spacing = base_spacing + (depth if depth < max_depth else max_depth - 1) * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 12))
nx.draw(
G, pos, with_labels=True, node_size=1000, node_color="lightblue",
font_size=10, edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
type(levels)
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
def generate_permutation_tree(letters):
G = nx.DiGraph()
levels = {0: [], 1: [], 2: []}
# Livello 0
for i, l in enumerate(letters):
levels[0].append((l, 0, i))
G.add_node(l)
# Livello 1
for (node0, _, _) in levels[0]:
for l1 in letters:
if l1 not in node0:
node1 = node0 + l1
levels[1].append((node1, 1, 0))
G.add_node(node1)
G.add_edge(node0, node1)
# Livello 2 (perm. complete)
for (node1, _, _) in levels[1]:
for l2 in letters:
if l2 not in node1:
node2 = node1 + l2
levels[2].append((node2, 2, 0))
G.add_node(node2)
G.add_edge(node1, node2)
return G, levels
def generate_fixed_last_level_positions(levels, base_spacing=3.5, expansion_factor=3.0):
pos = {}
max_depth = max(levels.keys())
for depth, nodes in levels.items():
width = len(levels[depth - 1]) if depth == max_depth else len(nodes)
spacing = base_spacing + (depth if depth < max_depth else max_depth - 1) * expansion_factor
y_positions = np.linspace(-width / 2, width / 2, len(nodes)) * spacing
for (name, x, _), y in zip(nodes, y_positions):
pos[name] = (x, y)
return pos
labels = {
"a": "a",
"ab": "b",
"abc": "c",
"ac": "c",
"acb": "b",
"b": "b",
"ba": "a",
"bac": "c",
"bc": "c",
"bca": "a",
"c": "c",
"ca": "a",
"cab": "b",
"cb": "b",
"cba": "a"
}
# Esegui
letters = ['c', 'b', 'a']
G, levels = generate_permutation_tree(letters)
pos = generate_fixed_last_level_positions(levels)
plt.figure(figsize=(10, 12))
nx.draw(
G, pos, labels=labels, node_size=1000, node_color="lightblue",
font_size=10, edge_color="gray", arrows=False
)
plt.title("Albero delle permutazioni di 3 lettere (fattoriale di 3)", fontsize=14)
plt.show()
levels
x = {
"nomi": ("A", "B", "C"),
"numeri": [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
}
x
for cosa in x:
print(cosa)
for chiave, valore in x.items():
print(chiave, "→", valore)
x.items()
x["nomi"]
x["numeri"]
x["numeri"][1]
x["numeri"][1][1]
x["numeri"][1][0]
x["numeri"][1][-1]
x["numeri"][1][-2]
for chiave, valore in x.items():
print(chiave, "→", valore)
x["numeri"][1][-2]
x["numeri"][1][-2]
for chiave, valore in x.items():
print(chiave, "→", valore)
x = {
"nomi": ("A", "B", "C"),
"numeri": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
}
x
for chiave, valore in x.items():
print(chiave, "→", valore)
x["numeri"][1][-2]
x["numeri"][1][-2] = 3
x = {
"nomi": ("A", "B", "C"),
"numeri": [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
}
x
for chiave, valore in x.items():
print(chiave, "→", valore)
x["numeri"][1][-2]=3
x["numeri"][1]
x["numeri"][1] = [2,3,1]
for chiave, valore in x.items():
print(chiave, "→", valore)
x = {
"nomi": ("A", "B", "C"),
"numeri": ((1, 2, 3), (4, 5, 6), (7, 8, 9))
}
x
x = {
"nomi": ("A", "B", "C"),
"numeri": ((1, 2, 3), (4, 5, 6), (7, 8, 9))
}
x
for chiave, valore in x.items():
print(chiave, "→", valore)
x["numeri"][1] = [2,3,1]
y = ("a",[1,2,3],"b")
y
